{"version":3,"sources":["../src/index.tsx"],"sourcesContent":["import { useMemo } from \"react\";\n\ntype DonutSectorProps = {\n  angle: number;\n  size: number;\n  thickness: number;\n  cornerRadius?: number;\n  color: string;\n};\n\ntype Vector = {\n  x: number;\n  y: number;\n};\n\nfunction renderDonutSector({\n  angle,\n  size,\n  thickness,\n  cornerRadius = 0,\n  color,\n}: DonutSectorProps): [string | null, number] {\n  const outerRadius = size / 2;\n  const innerRadius = outerRadius - thickness;\n\n  // Clamps angle at the point that leaves at least\n  // a 1px circumference on the inner circle\n  const maxAngle = 360 - 360 / (2 * Math.PI * innerRadius);\n\n  const path = getPath(\n    Math.min(maxAngle, angle),\n    thickness,\n    size,\n    cornerRadius\n  );\n\n  // 0 angle shouldn't render anything\n  if (angle === 0) return [null, outerRadius];\n\n  // 360 angle returns a full circle\n  if (angle >= 360) {\n    return [path, outerRadius];\n  }\n\n  return [path, outerRadius];\n}\n\nconst DonutSector = (props: DonutSectorProps) => {\n  const [path, outerRadius] = renderDonutSector(props);\n\n  if (!path) return null;\n\n  return (\n    <path\n      d={path}\n      fill={props.color}\n      cx={0}\n      cy={0}\n      r={outerRadius - props.thickness / 2}\n      stroke={props.color}\n      strokeWidth={props.thickness}\n      opacity=\"1\"\n    />\n  );\n};\n\nfunction generateDonutSector(props: DonutSectorProps): string {\n  const [path, outerRadius] = renderDonutSector(props);\n\n  if (!path) return \"\";\n\n  return `<path d=\"${path}\" fill=\"${props.color}\" cx=\"${0}\" cy=\"${0}\" r=\"${outerRadius - props.thickness / 2}\" fill=\"none\" stroke=\"${props.color}\" strokeWidth=\"${props.thickness}\" opacity=\"1\" />`;\n}\n\nfunction getPath(\n  angle: number,\n  thickness: number,\n  size: number,\n  cornerRadius: number\n) {\n  const outerRadius = size / 2;\n  const innerRadius = outerRadius - thickness;\n\n  // Min angle is a circumference of 2 * the cornerRadius\n  // so that it doesn't intersect itself\n  const circumference = calculateArcLength(angle, innerRadius);\n  const minAngle = (((cornerRadius * 2) / innerRadius) * 180) / Math.PI;\n  const clampedAngle = circumference < cornerRadius * 2 ? minAngle : angle;\n\n  // outerLineEnd = OuterLineEndBezier\n  const outerLineEnd = polarToCartesian(0, 0, outerRadius, clampedAngle);\n  // outerLineEndCornerXY1: Move back along circumference by corner radius\n  const outerLineEndCornerXY1 = moveAlongCircumference(\n    outerLineEnd,\n    outerRadius,\n    cornerRadius\n  );\n  // outerLineEndCornerBezier = Outer line end\n  const outerLineEndCornerBezier = outerLineEnd;\n  // outerLineEndCornerXY2: outerLineEndCornerBezier -> move towards origin by corner radius\n  const outerLineEndCornerXY2 = moveTowardsOrigin(\n    outerLineEndCornerBezier,\n    cornerRadius\n  );\n\n  // innerLineStartCornerXY1: Move towards origin by thickness - 2x corner radius\n  const innerLineStartCornerXY1 = moveTowardsOrigin(\n    outerLineEndCornerBezier,\n    thickness - cornerRadius\n  );\n  // innerLineStartCornerBezier: Move towards origin by corner radius\n  const innerLineStartCornerBezier = moveTowardsOrigin(\n    innerLineStartCornerXY1,\n    cornerRadius\n  );\n  // innerLineStartCornerXY2: Move back along circumference by corner radius\n  const innerLineStartCornerXY2 = moveAlongCircumference(\n    innerLineStartCornerBezier,\n    innerRadius,\n    cornerRadius\n  );\n\n  // innerLineEnd\n  const innerLineEnd = polarToCartesian(0, 0, innerRadius, 0);\n  // innerLineEndCornerXY1: Move back along circumference by corner radius * -1\n  const innerLineEndCornerXY1 = moveAlongCircumference(\n    innerLineEnd,\n    innerRadius,\n    cornerRadius * -1\n  );\n  // innerLineEndCornerBezier: innerLineEnd\n  const innerLineEndCornerBezier = innerLineEnd;\n  // innerLineEndCornerXY2: innerLineEndCornerBezier -> move away from origin by corner radius\n  const innerLineEndCornerXY2 = moveTowardsOrigin(\n    innerLineEndCornerBezier,\n    cornerRadius * -1\n  );\n\n  // outerLineStartCornerXY1: Move away from origin by thickness - 2x corner radius\n  const outerLinerStartCornerXY1 = moveTowardsOrigin(\n    innerLineEndCornerXY2,\n    (thickness - cornerRadius * 2) * -1\n  );\n  // outerLineStartCornerBezier: Move away from origin by corner radius\n  const outerLineStartCornerBezier = moveTowardsOrigin(\n    outerLinerStartCornerXY1,\n    cornerRadius * -1\n  );\n  // outerLineStartCornerXY2: Move back along circumference by corner radius\n  const outerLineStartCornerXY2 = moveAlongCircumference(\n    outerLineStartCornerBezier,\n    outerRadius,\n    cornerRadius * -1\n  );\n\n  // We figure out the new outer angle which is shorter on account\n  // of being reduced by the corner radius. If we don't do this it will\n  // throw off the large-arc-flag and sweep-flag\n  const newOuterAngle = calculateNewAngle(\n    outerRadius,\n    cornerRadius * 2,\n    clampedAngle\n  );\n  const newInnerAngle = calculateNewAngle(\n    innerRadius,\n    cornerRadius * 2,\n    clampedAngle\n  );\n\n  return `M ${outerLineStartCornerXY2.x},${outerLineStartCornerXY2.y}\n\t\t\tA ${outerRadius},${outerRadius},0,\n\t\t\t${+(Math.abs(newOuterAngle) > 180)},0,\n\t\t\t${outerLineEndCornerXY1.x},${outerLineEndCornerXY1.y}\n\t\t\tC ${outerLineEndCornerXY1.x} ${outerLineEndCornerXY1.y} ${\n    outerLineEndCornerBezier.x\n  } ${outerLineEndCornerBezier.y}  ${outerLineEndCornerXY2.x} ${\n    outerLineEndCornerXY2.y\n  }\n\t\t\tL ${innerLineStartCornerXY1.x} ${innerLineStartCornerXY1.y}\n\t\t\tC ${innerLineStartCornerXY1.x} ${innerLineStartCornerXY1.y} ${\n    innerLineStartCornerBezier.x\n  } ${innerLineStartCornerBezier.y}  ${innerLineStartCornerXY2.x} ${\n    innerLineStartCornerXY2.y\n  }\n\t\tA ${innerRadius},${innerRadius},0,\n\t\t${+(Math.abs(newInnerAngle) > 180)},1,\n\t\t${innerLineEndCornerXY1.x},${innerLineEndCornerXY1.y}\n\t\tC ${innerLineEndCornerXY1.x} ${innerLineEndCornerXY1.y} ${\n    innerLineEndCornerBezier.x\n  } ${innerLineEndCornerBezier.y}  ${innerLineEndCornerXY2.x} ${\n    innerLineEndCornerXY2.y\n  }\n\t\tL ${outerLinerStartCornerXY1.x} ${outerLinerStartCornerXY1.y}\n\t\tC ${outerLinerStartCornerXY1.x} ${outerLinerStartCornerXY1.y} ${\n    outerLineStartCornerBezier.x\n  } ${outerLineStartCornerBezier.y}  ${outerLineStartCornerXY2.x} ${\n    outerLineStartCornerXY2.y\n  }\n\t\t`;\n}\n\nfunction calculateNewAngle(\n  radius: number,\n  cornerRadius: number,\n  angle: number\n): number {\n  // Calculate the original circumference of the full circle\n  const originalCircumference = 2 * Math.PI * radius;\n\n  // Calculate the new circumference after reducing it by cornerRadius\n  const newCircumference = originalCircumference - 2 * cornerRadius;\n\n  return (newCircumference / originalCircumference) * angle;\n}\n\nfunction calculateArcLength(angle: number, radius: number): number {\n  // Convert angle to radians\n  const angleInRadians = (Math.PI / 180) * angle;\n\n  // Arc length formula: radius * angle (in radians)\n  return radius * angleInRadians;\n}\n\nfunction moveTowardsOrigin(current: Vector, distance: number): Vector {\n  const origin = { x: 0, y: 0 };\n  const totalDistance = Math.sqrt(\n    Math.pow(current.x - origin.x, 2) + Math.pow(current.y - origin.y, 2)\n  );\n\n  if (distance >= totalDistance) {\n    return origin;\n  }\n\n  const ratio = (totalDistance - distance) / totalDistance;\n\n  const newX = (current.x - origin.x) * ratio + origin.x;\n  const newY = (current.y - origin.y) * ratio + origin.y;\n\n  return { x: newX, y: newY };\n}\n\nfunction moveAlongCircumference(\n  current: Vector,\n  radius: number,\n  distance: number\n): Vector {\n  const origin = { x: 0, y: 0 };\n\n  // Convert the distance moved along the circumference to an angle in radians.\n  const angle = distance / radius;\n\n  // Find the current angle from the center to the current point.\n  const currentAngle = Math.atan2(current.y - origin.y, current.x - origin.x);\n\n  // Calculate the new angle.\n  const newAngle = currentAngle + angle;\n\n  // Calculate the new coordinates.\n  const newX = origin.x + radius * Math.cos(newAngle);\n  const newY = origin.y + radius * Math.sin(newAngle);\n\n  return { x: newX, y: newY };\n}\n\nfunction polarToCartesian(\n  cx: number,\n  cy: number,\n  radius: number,\n  angle: number\n) {\n  return {\n    x: cx + Math.cos((-Math.PI / 180) * angle) * radius,\n    y: cy + Math.sin((-Math.PI / 180) * angle) * radius,\n  };\n}\n\nexport { DonutSector, generateDonutSector };\n"],"mappings":"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","names":[]}